## wrapper around overlap plots
#' wrapper around Overlap plots
#' @description
#' "Wrapper around overlap plots" takes "DESeqCalculation" results,
#' k-mean clustering index groups, and computes running average
#' plots (log2 fold change vs mean gene length).
#'
#' Uses Overlay Gabel's moving average function which calculates the mean of
#' log2 fold change and genomic lengths. Computes p-values using student t-test
#' function, and returns overlay line plots.
#'
#' @param dat Differential analysis results from "DESeqCalculation"
#' @param refseq reference sequence
#' @param KO.idx Treatment group index
#' @param WT.idx Control group index
#' @param WT1.idx WT1 index
#' @param WT2.idx WT2 index
#' @param bin.size bin size
#' @param shift.size shift size
#' @param confidenceinterval CI
#' @param shrink_lfc Shrink log2 fold changes
#'
#' @return results and plots
#' @export
#'
#' @examples
#' ## Load annotation dataset
#' \dontrun{
#' load(file = "../../dat-info/mm10_ncbi-refSeqGene_Dec2019.RData")
#' genotypes <- factor(c(rep("WT", 10), rep("KO", 10)), levels = c("KO", "WT"))
#' ## Load gene counts
#' dat <- read.table(paste("../../dat/counts/GSE128178_10WT_",
#' "10MeCP2_KO_whole_cell_RNAseq_exon_counts.txt"),
#'            sep = "\t", stringsAsFactors=FALSE, header = TRUE, row.names = 1)
#' # Run DESeq analysis
#' wholeCell.KO <- DESeqCalculation(dat = dat, genotypes = genotypes, fc = 1.15)
#' mat <- wholeCell.KO$results[,c(8:27,1,3)]
#' colnames(mat)[21] <- "gene.name"
#' ## same cluster sizes
#' grp.idx <- WTgrpKmeans(control_mat = mat[,1:10])
#' ## Generate overlap plots
#' res1 <- overlapWrapper(dat = mat, refseq = refseq, KO.idx = c(11:20),
#'                         WT.idx = c(1:10), WT1.idx = grp.idx$WT.idx1,
#'                         WT2.idx = grp.idx$WT.idx2, bin.size = 200,
#'                         shift.size = 40)
#' res1$plot
#' }

## wrapper around overlap plots
overlapWrapper <- function(dat, refseq, KO.idx, WT.idx, WT1.idx, WT2.idx,
                            bin.size, shift.size, confidenceinterval = 0.50,
                           shrink_lfc = FALSE){
  dat.annot <- inner_join(x = dat, y = refseq, by = "gene.name")
  cat("Control Group 1:",WT1.idx,"\n")
  cat("Control Group 2:",WT2.idx,"\n")
  gene.idx <- which(colnames(dat.annot) %in% "gene.name")
  log2FC.WT <- dat.annot[,c(WT.idx, gene.idx)]
  log2FC.WT$comp.mat <- apply(log2FC.WT[, WT.idx], 1,
                              function(r){log2((mean(r[WT1.idx]) + 1) /
                                                 (mean(r[WT2.idx]) +1))})
  if(shrink_lfc == FALSE){
    log2FC.KO <- logofMeansBetweenAB(dat = dat.annot, A.samples = WT.idx,
                                        B.samples = KO.idx)
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = log2FC.KO[,c("gene.name","logFC.crude",
                                                 "gene.length")],
                                by = "gene.name")
  }else{
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = dat.annot[,c("gene.name",
                                                 "log2FoldChange",
                                                 "gene.length")],
                                by = "gene.name")
  }

  res <- overlayGabelsPlot(mat = log2FC.length[,c(2:4)],
                             comp.between1 = "(WT/WT)",
                             comp.between2 = "(KO/WT)", bin.size, shift.size,
                           confidenceinterval)
  plot.margin <- unit(c(1,0.5,0.5,0.5), "cm")
  res.plot <- plot_grid(res$plot1 + coord_cartesian(ylim = c(-0.4,0.4)),
                        res$plot2 + coord_cartesian(ylim = c(0,50)), ncol = 1,
                        align = 'v') + theme(plot.margin = plot.margin)
  return(list(res = res, plot = res.plot, log2FC.length = log2FC.length))
}

## kmeans
#' K-means original
#' @description
#' "K-means original" takes control (WT) subset of "DESeqCalculation" results
#' (which corresponds to Differential Expression analysis). Then, performs
#' k-means clustering with 2 clusters and outputs corresponding index groups.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the
#' results of Differential Expression analysis generated by "DESeqCalculation".
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrpKmeans(control_mat = mat)
## original k-means
WTgrpKmeans <- function(control_mat, centers = 2, iter.max = 1000){
  group <- kmeans(t(control_mat), centers, iter.max)$cluster
  idx1 <- which(group %in% 1)
  idx2 <- which(group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}

## k-means variation for equal cluster size
## tutorial: https://elki-project.github.io/tutorial/same-size_k_means
## points are ordered by their distance to the closest center minus the distance
## to the farthest cluster. Each point is assigned to the best cluster in order.
#' K-means variation for equal cluster size
#'
#' @description
#' "K-means variation for equal cluster size" takes control (WT) subset of
#' "DESeqCalculation" results (which corresponds to Differential Expression
#' analysis). Then, performs k-means clustering with 2 clusters and outputs
#' corresponding index groups.
#'
#' Additional notes...
#'
#' tutorial: https://elki-project.github.io/tutorial/same-size_k_means
#' points are ordered by their distance to the closest center minus the distance
#' to the farthest cluster. Each point is assigned to the best cluster in order.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the
#' results of Differential Expression analysis generated by "DESeqCalculation".
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrpKmeans(control_mat = mat)
WTgrpKmeansEqualSize <- function(control_mat, centers = 2, iter.max = 1000){
  size <- ceiling(nrow(t(control_mat))/centers)
  group <- kmeans(t(control_mat), centers, iter.max)
  new_group <- rep(NA, nrow(t(control_mat)))
  new_centers <- lapply(1:centers, function(r){
    euc_dist <- control_mat - group$centers[r,]
    sqrt(apply(euc_dist, 2, function(x) sum(x^2)))})
  new_centers <- matrix(unlist(new_centers), ncol = centers)
  new_clust_size <- rep(0, centers)
  sample_ord <- order(apply(new_centers, 1, min) - apply(new_centers, 1, max))
  for(i in sample_ord){
    bestcl <- which.max(new_centers[i,])
    new_group[i] <- bestcl
    new_clust_size[bestcl] <- new_clust_size[bestcl] + 1
    if(new_clust_size[bestcl] >= size){
      new_centers[,bestcl] <- NA
    }
  }
  idx1 <- which(new_group %in% 1)
  idx2 <- which(new_group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}


#' wrapper around Overlap plots for DEGs mCA
#'
#' @param degs.dat DEGs data
#' @param count.dat counts data
#' @param refseq reference sequence
#' @param WT1.idx WT1 index
#' @param WT2.idx WT2 index
#' @param bin.size bin size
#' @param shift.size shift size
#' @param methyl.type methylation type
#' @param degs DEGs
#'
#' @return Overlay mC plots
#' @export
#'
#' @examples
#'\dontrun{
#' ## load the workspace
#' load(file = "../../dat-info/mm10_ncbi-refSeqGene_Dec2019.RData")
#' mCA <- data.frame(readRDS("../../dat/mCA/CAperGene_10wk_boxer.RDS"), stringsAsFactors = FALSE)
#' mCA <- mCA[mCA$CA >= 5,]
#' mCA <- mCA[mCA$gene.length >= 4500,]
#' mCA$mCA.CA <- mCA$mCA/mCA$CA
#' mCA1 <- mCA[,c(1,6,7)]
#' ## mCA analysis for KO/WT in whole cell dataset
#' degs.dat <- read.table("../../dat/DEGs/KO-WT_whole-cell_RNA-seq.txt", sep = "\t",
#'                        stringsAsFactors = FALSE, header = TRUE, row.names = 1)
#' mat <- wholeCell.KO$res$results[,c(8:27,1,3)]
#' colnames(mat)[21] <- "gene.name"
#' grp.idx <- WTgrpKmeans(control_mat = mat[,1:10])
#' if(length(grp.idx$WT.idx1) != length(grp.idx$WT.idx2)){
#'   message("Cluster size is not equal, therefore run same size k-means
#'                 variation!")
#'   grp.idx <- WTgrpKmeansEqualSize(control_mat = mat[,1:10])
#' }
#' res1 <- overlapDegsmCAWrapper(degs.dat = degs.dat, count.dat = mat,
#'                               refseq = mCA1, WT1.idx = grp.idx$WT.idx1,
#'                               WT2.idx = grp.idx$WT.idx2, bin.size = 60,
#'                               shift.size = 6, methyl.type = "mCA/CA")
#'
#'}
#'
overlapDegsmCAWrapper <- function(degs.dat, count.dat, refseq, WT1.idx,
                                     WT2.idx, bin.size, shift.size, methyl.type,
                                     degs = TRUE){
  if(degs == TRUE){
    degs.dat <- degs.dat[degs.dat$FDR < 0.05,]
  }
  cat("Number of genes =",dim(degs.dat)[1],"\n\n")
  degs.dat <- inner_join(degs.dat %>% rownames_to_column(var = "gene.name"),
                         refseq, #%>% rownames_to_column(var = "gene.name"),
                         by = "gene.name")
  ## overlap plot
  cat("Control Group 1:",WT1.idx,"\n")
  cat("Control Group 2:",WT2.idx,"\n")
  log2FC.WT <- data.frame(count.dat[,c(1:10, 21)], stringsAsFactors = FALSE)
  log2FC.WT$comp.mat <- apply(count.dat[,c(WT1.idx, WT2.idx)], 1,
                              function(r){log2((mean(r[1:length(WT1.idx)])+1) /
                                                 (mean(r[(length(WT1.idx)+1):10])+1))})
  log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                              y = degs.dat[,c("gene.name","logFC",
                                              "gene.length","mCA.CA")],
                              by = "gene.name")
  message(dim(log2FC.length)[1])
  print(log2FC.length[,c(2:5,1)])
  res <- overlaymC(mat = log2FC.length[,c(2:5,1)], comp.between1 = "(WT/WT)",
                    comp.between2 = "(KO/WT)", bin.size = bin.size,
                    shift.size = shift.size, methyl.type = methyl.type)
  return(res = res)
}

