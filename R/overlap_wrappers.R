## wrapper around overlap plots
#' wrapper around Overlap plots
#' @description
#' "Wrapper around overlap plots" takes "DESeqCalculation" results,
#' k-mean clustering index groups, and computes running average
#' plots (log2 fold change vs mean gene length).
#'
#' Uses Overlay Gabel's moving average function which calculates the mean of
#' log2 fold change and genomic lengths. Computes p-values using student t-test
#' function, and returns overlay line plots.
#'
#' @param dat Differential analysis results from "DESeqCalculation"
#' @param refseq reference sequence
#' @param KO.idx Treatment group index
#' @param WT.idx Control group index
#' @param WT1.idx WT1 index
#' @param WT2.idx WT2 index
#' @param bin.size bin size
#' @param shift.size shift size
#' @param shrink_lfc Shrink log2 fold changes
#'
#' @return results and plots
#' @export
#'
#' @examples
#' ## Load annotation dataset
#' \dontrun{
#' load(file = "../../dat-info/mm10_ncbi-refSeqGene_Dec2019.RData")
#' genotypes <- factor(c(rep("WT", 10), rep("KO", 10)), levels = c("KO", "WT"))
#' ## Load gene counts
#' dat <- read.table(paste("../../dat/counts/GSE128178_10WT_",
#' "10MeCP2_KO_whole_cell_RNAseq_exon_counts.txt"),
#'            sep = "\t", stringsAsFactors=FALSE, header = TRUE, row.names = 1)
#' # Run DESeq analysis
#' wholeCell.KO <- DESeqCalculation(dat = dat, genotypes = genotypes, fc = 1.15)
#' mat <- wholeCell.KO$results[,c(8:27,1,3)]
#' colnames(mat)[21] <- "gene.name"
#' ## same cluster sizes
#' grp.idx <- WTgrp_kmeans(control_mat = mat[,1:10])
#' ## Generate overlap plots
#' res1 <- overlap_wrapper(dat = mat, refseq = refseq, KO.idx = c(11:20),
#'                         WT.idx = c(1:10), WT1.idx = grp.idx$WT.idx1,
#'                         WT2.idx = grp.idx$WT.idx2, bin.size = 200,
#'                         shift.size = 40)
#' res1$plot
#' }

## wrapper around overlap plots
overlap_wrapper <- function(dat, refseq, KO.idx, WT.idx, WT1.idx, WT2.idx,
                            bin.size, shift.size, shrink_lfc = FALSE){
  dat.annot <- inner_join(x = dat, y = refseq, by = "gene.name")
  cat("Control Group 1:",WT1.idx,"\n")
  cat("Control Group 2:",WT2.idx,"\n")
  gene.idx <- which(colnames(dat.annot) %in% "gene.name")
  log2FC.WT <- dat.annot[,c(WT.idx, gene.idx)]
  log2FC.WT$comp.mat <- apply(log2FC.WT[, WT.idx], 1,
                              function(r){log2((mean(r[WT1.idx]) + 1) /
                                                 (mean(r[WT2.idx]) +1))})
  if(shrink_lfc == FALSE){
    log2FC.KO <- logofMeans.between.A.B(dat = dat.annot, A.samples = WT.idx,
                                        B.samples = KO.idx)
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = log2FC.KO[,c("gene.name","logFC.crude",
                                                 "gene.length")],
                                by = "gene.name")
  }else{
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = dat.annot[,c("gene.name",
                                                 "log2FoldChange",
                                                 "gene.length")],
                                by = "gene.name")
  }
  res <- overlay.gabels.plot(mat = log2FC.length[,c(2:4)],
                             comp.between1 = "(WT/WT)",
                             comp.between2 = "(KO/WT)", bin.size, shift.size)
  plot.margin <- unit(c(1,0.5,0.5,0.5), "cm")
  res.plot <- plot_grid(res$plot1 + coord_cartesian(ylim = c(-0.4,0.4)),
                        res$plot2 + coord_cartesian(ylim = c(0,50)), ncol = 1,
                        align = 'v') + theme(plot.margin = plot.margin)
  return(list(res = res, plot = res.plot, log2FC.length = log2FC.length))
}

## kmeans
#' K-means original
#' @description
#' "K-means original" takes control (WT) subset of "DESeqCalculation" results
#' (which corresponds to Differential Expression analysis). Then, performs
#' k-means clustering with 2 clusters and outputs corresponding index groups.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the
#' results of Differential Expression analysis generated by "DESeqCalculation".
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrp_kmeans(control_mat = mat)
## original k-means
WTgrp_kmeans <- function(control_mat, centers = 2, iter.max = 1000){
  group <- kmeans(t(control_mat), centers, iter.max)$cluster
  idx1 <- which(group %in% 1)
  idx2 <- which(group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}

## k-means variation for equal cluster size
## tutorial: https://elki-project.github.io/tutorial/same-size_k_means
## points are ordered by their distance to the closest center minus the distance
## to the farthest cluster. Each point is assigned to the best cluster in order.
#' K-means variation for equal cluster size
#'
#' @description
#' "K-means variation for equal cluster size" takes control (WT) subset of
#' "DESeqCalculation" results (which corresponds to Differential Expression
#' analysis). Then, performs k-means clustering with 2 clusters and outputs
#' corresponding index groups.
#'
#' Additional notes...
#'
#' tutorial: https://elki-project.github.io/tutorial/same-size_k_means
#' points are ordered by their distance to the closest center minus the distance
#' to the farthest cluster. Each point is assigned to the best cluster in order.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the
#' results of Differential Expression analysis generated by "DESeqCalculation".
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrp_kmeans(control_mat = mat)
WTgrp_kmeans_eqSize <- function(control_mat, centers = 2, iter.max = 1000){
  size <- ceiling(nrow(t(control_mat))/centers)
  group <- kmeans(t(control_mat), centers, iter.max)
  new_group <- rep(NA, nrow(t(control_mat)))
  new_centers <- lapply(1:centers, function(r){
    euc_dist <- control_mat - group$centers[r,]
    sqrt(apply(euc_dist, 2, function(x) sum(x^2)))})
  new_centers <- matrix(unlist(new_centers), ncol = centers)
  new_clust_size <- rep(0, centers)
  sample_ord <- order(apply(new_centers, 1, min) - apply(new_centers, 1, max))
  for(i in sample_ord){
    bestcl <- which.max(new_centers[i,])
    new_group[i] <- bestcl
    new_clust_size[bestcl] <- new_clust_size[bestcl] + 1
    if(new_clust_size[bestcl] >= size){
      new_centers[,bestcl] <- NA
    }
  }
  idx1 <- which(new_group %in% 1)
  idx2 <- which(new_group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}
