## wrapper around overlap plots
#' wrapper around Overlap plots
#' @description
#' "Wrapper around overlap plots" takes "DESeqCalculation" results, k-mean clustering index groups, and computes running average
#' plots (log2 fold change vs mean gene length).
#'
#' Uses Overlay Gabel's moving average function which calculates the mean of log2
#' fold change and genomic lengths. Computes p-values using student t-test function,
#' and returns overlay line plots.
#'
#' @param dat Differential analysis results from "DESeqCalculation"
#' @param refseq reference sequence
#' @param KO.idx Treatment group index
#' @param WT.idx Control group index
#' @param WT1.idx WT1 index
#' @param WT2.idx WT2 index
#' @param bin.size bin size
#' @param shift.size shift size
#' @param shrink_lfc Shrink log2 fold changes
#'
#' @return results and plots
#' @export
#'
#' @examples
#' \dontrun{
#' # Generate arbitrary toy data
#' dat <- matrix(rnbinom(n=10000, mu=100, size= 1/0.5),ncol=20)
#' for (x in 1:250) {
#' dat[x,] <- dat[x,] + sample(800:1200, 10, replace=T)
#' }
#' for (x in 250:500) {
#' dat[x,] <- dat[x,] + sample(0:100, 10, replace=T)
#' }
#' for (x in 1:5) {
#' dat[,x] <- dat[,x] + sample(800:1000, 5, replace=T)
#' }
#' dat <- matrix(as.numeric(dat), ncol = ncol(dat))
#' colnames(dat) <- c("MeCP2_WT_1",	"MeCP2_WT_2",	"MeCP2_WT_3",
#' "MeCP2_WT_4",	"MeCP2_WT_5",	"MeCP2_WT_6", "MeCP2_WT_7", "MeCP2_WT_8",
#' "MeCP2_WT_9", "MeCP2_WT_10", "MeCP2_KO_1",	"MeCP2_KO_2",	"MeCP2_KO_3",
#' "MeCP2_KO_4",	"MeCP2_KO_5", "MeCP2_KO_6", "MeCP2_KO_7", "MeCP2_KO_8",
#' "MeCP2_KO_9", "MeCP2_KO_10")
#' vec <- as.character(seq(1,500, by = 1))
#' row.names(dat) <- vec
#' genotypes <- factor(c(rep("WT", 10), rep("KO", 10)), levels = c("KO", "WT"))
#' # Run Differential Analysis
#' wholeCell.KO <- DESeqCalculation(dat = dat,genotypes = genotypes, fc = 1.15)
#' # Plot figures
#' mat <- wholeCell.KO$results[,c(8:27,1,3)]
#' colnames(mat)[21] <- "gene.name"
#' grp.idx <- WTgrp_kmeans(control_mat = mat[,1:10])
#' res1 <- overlap_wrapper(dat = mat, refseq = refseq, KO.idx = c(11:20),
#'                         WT.idx = c(1:10), WT1.idx = grp.idx$WT.idx1,
#'                         WT2.idx = grp.idx$WT.idx2, bin.size = 200,
#'                         shift.size = 40)
#' res1$plot
#' }
## wrapper around overlap plots
overlap_wrapper <- function(dat, refseq, KO.idx, WT.idx, WT1.idx, WT2.idx,
                            bin.size, shift.size, shrink_lfc = F){
  dat.annot <- inner_join(x = dat, y = refseq, by = "gene.name")
  cat("Control Group 1:",WT1.idx,"\n")
  cat("Control Group 2:",WT2.idx,"\n")
  gene.idx <- which(colnames(dat.annot) %in% "gene.name")
  log2FC.WT <- dat.annot[,c(WT.idx, gene.idx)]
  log2FC.WT$comp.mat <- apply(log2FC.WT[, WT.idx], 1,
                              function(r){log2((mean(r[WT1.idx]) + 1) /
                                                 (mean(r[WT2.idx]) +1))})
  if(shrink_lfc == FALSE){
    log2FC.KO <- logofMeans.between.A.B(dat = dat.annot, A.samples = WT.idx,
                                        B.samples = KO.idx)
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = log2FC.KO[,c("gene.name","logFC.crude",
                                                 "gene.length")],
                                by = "gene.name")
  }else{
    log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
                                y = dat.annot[,c("gene.name",
                                                 "log2FoldChange",
                                                 "gene.length")],
                                by = "gene.name")
  }
  res <- overlay.gabels.plot(mat = log2FC.length[,c(2:4)],
                             comp.between1 = "(WT/WT)",
                             comp.between2 = "(KO/WT)", bin.size, shift.size)
  plot.margin <- unit(c(1,0.5,0.5,0.5), "cm")
  res.plot <- plot_grid(res$plot1 + coord_cartesian(ylim = c(-0.4,0.4)),
                        res$plot2 + coord_cartesian(ylim = c(0,50)), ncol = 1,
                        align = 'v') + theme(plot.margin = plot.margin)
  return(list(res = res, plot = res.plot, log2FC.length = log2FC.length))
}

## kmeans
#' K-means original
#' @description
#' "K-means original" takes control (WT) subset of "DESeqCalculation" results
#' (which corresponds to Differential Expression analysis). Then, performs k-means
#' clustering with 2 clusters and outputs corresponding index groups.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the results
#' of Differential Expression analysis generated by "DESeqCalculation"
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrp_kmeans(control_mat = mat)
## original k-means
WTgrp_kmeans <- function(control_mat, centers = 2, iter.max = 1000){
  group <- kmeans(t(control_mat), centers, iter.max)$cluster
  idx1 <- which(group %in% 1)
  idx2 <- which(group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}

## k-means variation for equal cluster size
## tutorial: https://elki-project.github.io/tutorial/same-size_k_means
## points are ordered by their distance to the closest center minus the distance
## to the farthest cluster. Each point is assigned to the best cluster in order.
#' K-means variation for equal cluster size
#'
#' @description
#' "K-means variation for equal cluster size" takes control (WT) subset of "DESeqCalculation" results
#' (which corresponds to Differential Expression analysis). Then, performs k-means
#' clustering with 2 clusters and outputs corresponding index groups.
#'
#' Additional notes...
#'
#' tutorial: https://elki-project.github.io/tutorial/same-size_k_means
#' points are ordered by their distance to the closest center minus the distance
#' to the farthest cluster. Each point is assigned to the best cluster in order.
#'
#' @param control_mat a Dataframe containing the control (WT) subset from the results
#' of Differential Expression analysis generated by "DESeqCalculation"
#' @param centers number of centers/clusters default = 2
#' @param iter.max max number of iterations default = 1000
#'
#' @return labeled index from k-means clustering
#' @export
#'
#' @examples
#' mat <- rbind(matrix(rnorm(1000, sd = 0.3), ncol = 10),
#' matrix(rnorm(1000, mean = 1, sd = 0.3), ncol = 10))
#' WTgrp_kmeans(control_mat = mat)
WTgrp_kmeans_eqSize <- function(control_mat, centers = 2, iter.max = 1000){
  size <- ceiling(nrow(t(control_mat))/centers)
  group <- kmeans(t(control_mat), centers, iter.max)
  new_group <- rep(NA, nrow(t(control_mat)))
  new_centers <- lapply(1:centers, function(r){
    euc_dist <- control_mat - group$centers[r,]
    sqrt(apply(euc_dist, 2, function(x) sum(x^2)))})
  new_centers <- matrix(unlist(new_centers), ncol = centers)
  new_clust_size <- rep(0, centers)
  sample_ord <- order(apply(new_centers, 1, min) - apply(new_centers, 1, max))
  for(i in sample_ord){
    bestcl <- which.max(new_centers[i,])
    new_group[i] <- bestcl
    new_clust_size[bestcl] <- new_clust_size[bestcl] + 1
    if(new_clust_size[bestcl] >= size){
      new_centers[,bestcl] <- NA
    }
  }
  idx1 <- which(new_group %in% 1)
  idx2 <- which(new_group %in% 2)
  return(list(WT.idx1 = idx1, WT.idx2 = idx2))
}


## for DEGs
# overlap_degs_wrapper <- function(degs.dat, count.dat, refseq,
#                                  WT1.idx, WT2.idx,
#                                  bin.size, shift.size){
#   degs.dat <- degs.dat[degs.dat$FDR < 0.05,]
#   cat("Number of DEGs =",dim(degs.dat)[1],"\n\n")
#   degs.dat <- inner_join(degs.dat %>% rownames_to_column(var = "gene.name"),
#                          refseq, by = "gene.name")
#   Plot.Scatter(dat = degs.dat[,c("gene.name","logFC", "FDR", "gene.length")],
#                log2FC = log2(1), comp.between = "")
#   Plot.Scatter(dat = degs.dat[,c("gene.name","logFC", "FDR", "gene.length")],
#                log2FC = log2(1.2), comp.between = "")
#
#   ## overlap plot
#   cat("Control Group 1:",WT1.idx,"\n")
#   cat("Control Group 2:",WT2.idx,"\n")
#   log2FC.WT <- data.frame(count.dat[,c(1:10)], gene.name = rownames(count.dat),
#                           stringsAsFactors = F)
#   log2FC.WT$comp.mat <- apply(count.dat, 1,
#                               function(r){log2((mean(r[WT1.idx])+1) /
#                                                    (mean(r[WT2.idx])+1))})
#   log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
#                               y = degs.dat[,c("gene.name","logFC", "gene.length")],
#                               by = "gene.name")
#   message(dim(log2FC.length)[1])
#   res <- overlay.gabels.plot(mat = log2FC.length[,c(2:4)],
#                              comp.between1 = "(WT/WT)", comp.between2 = "(KO/WT)",
#                              bin.size = bin.size, shift.size = shift.size)
#   res.plot <- plot_grid(res$plot1 + coord_cartesian(ylim = c(-0.4,0.4)),
#                         res$plot2 + coord_cartesian(ylim = c(0,10)),
#                         ncol = 1, align = 'v') +
#               theme(plot.margin = unit(c(1,0.5,0.5,0.5), "cm"))
#   return(list(res = res, plot = res.plot, log2FC.length =log2FC.length))
# }
#
# overlap_degs_mCA_wrapper <- function(degs.dat, count.dat, refseq,
#                                      WT1.idx, WT2.idx, bin.size,
#                                      shift.size, methyl.type, degs = TRUE){
#   if(degs == TRUE){
#     degs.dat <- degs.dat[degs.dat$FDR < 0.05,]
#   }
#   cat("Number of genes =",dim(degs.dat)[1],"\n\n")
#   degs.dat <- inner_join(degs.dat %>% rownames_to_column(var = "gene.name"),
#                          refseq, #%>% rownames_to_column(var = "gene.name"),
#                          by = "gene.name")
#   ## overlap plot
#   cat("Control Group 1:",WT1.idx,"\n")
#   cat("Control Group 2:",WT2.idx,"\n")
#   log2FC.WT <- data.frame(count.dat[,c(1:10)], gene.name = rownames(count.dat),
#                           stringsAsFactors = F)
#   log2FC.WT$comp.mat <- apply(count.dat[,c(WT1.idx,WT2.idx)], 1,
#                               function(r){log2((mean(r[1:length(WT1.idx)])+1)/(mean(r[(length(WT1.idx)+1):10])+1))})
#   log2FC.length <- inner_join(x = log2FC.WT[,c("gene.name","comp.mat")],
#                               y = degs.dat[,c("gene.name","logFC",
#                                               "gene.length","mCA.CA")],
#                               by = "gene.name")
#   message(dim(log2FC.length)[1])
#   res <- overlay.mC(mat = log2FC.length[,c(2:5,1)], comp.between1 = "(WT/WT)",
#                     comp.between2 = "(KO/WT)", bin.size = bin.size,
#                     shift.size = shift.size, methyl.type = methyl.type)
#   return(res = res)
# }
